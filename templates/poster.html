{% extends "base.html" %}
{% block content %}

<style>
  .cs1999-tasks {
    border-top: 1px solid black;
    margin-top: 4em;
  }
  .cs1999-tasks .task {
    margin: 1em;
    padding: 1em;
    border: 1px solid black;
  }
  .cs1999-tasks .task h2 {
    border-bottom: 3px solid gray;
  }
</style>

<!-- see tech note about the poster:  
      https://rhul-cs-projects.github.io/CS1999-buggy-race-server/                -->
<!--                                                                              -->
<!-- anything you want here: make it beautiful! make it appealing! make it clear! -->
<!-- you can drop images into static/assets if you want... and access them        -->
<!-- here with <img src="/static/image-filename.png" alt="diagram" />             -->
<!--                                                                              -->
<!-- Of course you can edit static/app.css too if you want. It's your webserver,  -->
<!--                                                                              -->
<!-- Maybe... delete all these comments too :-)                                   -->


<!-- below this point keep this section tag and paste in a <div> for every        -->
<!-- task you attempted.                                                          -->
<section class="cs1999-tasks">
    <div class="task">
        <h2>0-GET</h2>
        <p>
            I forked the repo on GitHub and then installed VSCode so I could edit and keep track of changes,
            after correcting an error I was able to access the source code.
        </p>
        <p>
            Once I installed VSCode and ran the automated file given to me, unfortunately I kept getting an error
            saying that the connection could not be established to the linux server. After digging aroudn in VSCode logs, 
            I noticed that an error kept popping up about a file not existing. I saw the path it kept trying to
            access, the program wanted to access and/or create an ssh key. So I created an empty 'config' file 
            on my local '.ssh' folder and added this path to VSCode's settings. This then allowed me to login 
            into the linux server after entering my password.
        </p>
    </div>

    <div class="task">
        <h2>0-RUN Get app running and view it in a browser</h2>
        <p>
            I installed the requirements, then ran the 'app.py' file.
        </p>
        <p>
            Once I was able to access the source code, I could then install the necessary requirements Python needed in
            order to run the entire app. Installation was straightforward and ran into no errors. Once that was done,
            I was able to run the 'app.py' file successfully and was able to display the webserver in my own browser. 
        </p>
    </div>

    <div class="task">
        <h2>0-CHANGE Make a change to a template and see it appear</h2>
        <p>
            I added a a button to the home webpage to redirect to the page of this 'poster' and the 'info' page. 
            I was then able to make my first commit and push it to the my GitHub repo.
        </p>
    </div>

    <div class="task">
        <h2>1-TEMPLATE Add a new template to the app</h2>
        <p>
            Info html file edited to display INFO.
        </p>
    </div>

    <div class="task">
      <h2>1-TEMPLATE Add a new template to the app</h2>
      <p>
        I added a button to home page which redirected to new 'info.html'. This page is an almagamation of all tables
        in the buggy server INFO page, the app scrapes the page in real time and renders it 'on-the-fly'. To do this,
        I installed the BeautifulSoup python library which is used to parse and navitage HTML files/webpages. 
        After only scraping sections of the webpage and removing the first (as this table only shows info regarding
        defaul values which were not needed). After which, I could then pass the tables as an argument to 'render_template'.
        But before they could be rendered, I had to edit the file stating that they were 'safe', as Flask, by default, assumes 
        all texts are 'unsafe' and not to be rendered as HTML, instead showing it as text.
      </p>
    </div>

    <div class="task">
        <h2>1-ADD Add more data to the form</h2>
        <p>
          I made the form as a table so that I could add rows for user to input information. With each correspoding attribute,
          I made sure the right type of data was being inupt, e.g., for integers I made sure to add to the HTMl 
          page that the type was 'number' and could only add in steps of '1' - ensuring only integers could be used as input. 
        </p>
        <p>
          
        </p>
    </div>


    <div class="task">
        <h2>
            1-VALID Add basic data validation
        </h2>
        
        <p>
          I added further in constraints to inputs in form, for example certain integers had to be at least 0 or 1, 
          so I added a min HTML attribute. Or when the input could only be a selection, so I coded for only specific 
          options avaiable, instead of simple adding a text box through which incorrect inputs could be added. 
          Of course, all of this is client-side form validation.
        </p>
        
        <p>
          I was able to add further constratint which relate to another form input, the number of tyres needing to be equal to or greater than
          the number of wheels. I was able to add this by adding javascript to the HTML file and running it when the submit button was
          clicked. An error message window pops up if this constraint is not met.

          I then had to make sure that is an option was empty, then to simply not push anything for that specific attribute to the DB, otherwise
          each time a space if left blank then it overwrites that attribute in the DB. But I then ran onto a problem: what about the
          boolean values? You cannot leave a check box "empty", as this would register as False, thus what would happen if a user wanted to change
          it from True ro false? If I put this code for the non-boolean values for booleans values then said variable would be 
          set to True once and then not be able to change them. To fix this, when redering the HTML file, Python would pass these
          values onto the HTML file and check them if DB passed true otherwise leave them alone, but ALWAYS being posted to DB.
          
        </p>  
    </div>

    
    <div class="task">
      <h2>
        1-STYLE Style your editor just how you like it
      </h2>
      
      <p>
        I decided to make a sidebar so that all buttons for each page would show up on each page and allow
        user to travel inbetween all pages instead of simply having ti click "Home" and then choose the page they 
        want to go to. To do this, I have to create a template for the side bar separately, that way I could just import
        it with each page rather than copy and paste it. Once that was completed, I edited the CSS file to ensure 
        everything worked well and there were no hitches. With everythin set in place, I just had to decide where to 
        add the files, and for that I decided to go to the "base.html" file, as all the webpages preload it, and that 
        way I did not have to edit every other page.  
      </p>
        
    </div>

    <div class="task">
      <h2>2-EDIT Edit the record by loading its current values into the form</h2>
      <p>
        Todo this, I decided to change the current way buggy information was being retrieved. From directly accessing 
        the Database to using flask's own, built-in forms and models. With this, I could get values from Database, load it onto 
        the form class and pass it as an argument to template. If the form is prefilled, then  it will show up on 
        the HTML form.
      </p>
      <p>
        To build a form, I needed to learn how to use the FlaskWTForms library and how to incoorporate it into 
        my current setting. At first, I saw that I could make data retrieval easier by also adding in "models".
        Remembering both were 2 separate things was somewhat hard to. 
      </p>
    </div>
    <div class="task">
      <h2>2-FORM Make the form better</h2>
      <p>
        To make form better, I made sure that a single editing template was to be used, and every page which required it
        was to use that one. This made sure that any future changes I made to the form, would also show up on every page 
        that also used the editing form (the create new buggy and edit buggy pages).
      </p>
      <p>
        I also included something called a CSRF Token which is used to protect that against attack which try to impersonate 
        smoeone by submitting the form again. But with the token, the attacker needs to also guess said token, thus rendering
        the attack useless. Although not needed in this project, I decided to include it simply because I thought it interesting.
      </p>
    </div>
    <div class="task">
      <h2>2-COST Calculate and save the game cost of the buggy</h2>
      <p>
        I created a separate python file in which it contained functions to calculate the cost of a buggy. For this, however,
        I needed to read the specs again to make sure I knew all the attributes which changed cost. After this, I had to find a 
        way to get the associated costs of each attribute and how one attribute affected another, for example how the cost
        of armor is affected if the number of wheels is greater than 4.

        I also had to drop the current buggy table in order to add a cost column, as SQLite does not allow someone to create
        a new column once a table is created.
      </p>
      <p>
        While trying to retrieve costs of attributes which were applied to buggy, I tried to scrap the page of tabulated tables
        which took me a week to try and find a way to turn the table of information into something easier to manipulate and 
        retrieve - a dictionary. However, I later came to find out that a URL was avaiable in which a JSON format of the
        table was already compiled. This gave me equal amounts of relief and anger as I had spent a significant amount of time
        on the other solution. 
      </p>
    </div>
    <div class="task">
      <h2>2-RULES Add validation according to the game rules</h2>
      <p>
        Although form validation is built-in into the FlaskWTForms, I decide to simply use javascript as it was easier to implement
        (required the fewest changes, code-wise) and it was client-side, so, in theory, if this server were to be ever implemented 
        in the real world, there would be less bandwidth used on the server-side.
      </p>
      <p>
        To implement this I had to be careful with the naming of the variables of the buggy form, since FlaskWTForms rendered each 
        HTML object, I could not edit the name of the form which is needed for JS validation - which I later found out to be
        the forms' variable names. It also took me some time on how to implement the JS validation as in the beginning, the form kept
        being submitted anyway, by-passing the JS script. I then found out it was the same problem which I ran into when implementing
        CSS - the browser kept caching earlier, incomplete version of the JS script.
      </p>
    </div>
    <div class="task">
      <h2>3-ENV Switch between dev and production environments</h2>
      <p>
        Before starting my flask server, I would simply type <code>export FLASK_ENV=development</code> onto the terminal.
        Once I ran flask (<code>flask run</code>), debug mode would be turned on. If I wanted it in production mode, I would simply
        stop running the server, type <code>FLASK_ENV=0</code> and run flask again.
      </p>
      <p>
        Because I eventually changed file names, I also had to type <code>export FLASK_APP=main.py</code> before running the server.
      </p>
    </div>
    <div class="task">
      <h2>3-AUTOFILL Add auto-fill to the edit forms</h2>
      <p>
        Because FlaskWTForms allows you to pre-fill form data, this was easy to implement. I just created a list of 
        default values, and then loaded them into the form class.
      </p>
      <p>
        Updating existing buggies proved to somewhat hard due to lack of documentation. But after some searching, 
        I found out how to do it and it was easier than what seemed at first, it simply just needed a dictionary of the 
        attributes as keys and new values as values of their respective keys.
      </p>
    </div>
    <div class="task">
      <h2>3-MULTI Allow different buggies to be created</h2>
      <p>
        At this point, I had already created a database for buggies. But at the beggining I created a class for the table's 
        schema I desired. All the attributes of the buggy, the unique ID each buggy would have, their name and the cost 
        and mass of the buggy. With each attribute, I entered their respective data type and constraints, 
        for example the name of the buggy can only be 35 characters long. Since certain attributes are preset, they do not
        need to be as long, for example the longest string in the armor options is 12 characters.
      </p>
      <p>
        Any time I decided to change anything in the database class, I needed to drop the table and recreate the table 
        by running the following in the Python commandline: <code>from main import db, create_app</code>,
        <code>import models</code>, <code>db.create_all(app=create_all())</code>.
      </p>
    </div>
    <div class="task">
      <h2>3-DEL Allow buggies to be deleted</h2>
      <p>
        Deleting a row of the Database was easy, as it only needed a method to be called after calling the specific row, then saving
        the new Database changes.
      </p>
    </div>
    <div class="task">
      <h2>3-FLAG Display the pennant graphically</h2>
      <p>
        I decided to add IF-ELIF blocks on the <code>display.html</code>, where, depending on the pattern user chose, only the specific
        CSS style is rendered. The class of the table cell is set to their correspoding flag pattern, with the special case 
        of <code>spot</code>, which also adds in a div inside it so the circle can be rendered.  
      </p>
      <p>
        It took me a while to find a solution on how to render the spot pattern, I then decided that it could only be done with 
        two parts: the background being the main the colour, and the circle in the middle as the secondary colour. 
      </p>
    </div>
    <div class="task">
      <h2>3-TESTS Write some tests</h2>
      <p>
        With testing each new changes, I would create a function and pass the testing arguments, the function would return
        the values and then I would compare with what it would return. 
      </p>
    </div>
    <div class="task">
      <h2>4-USERS Add users (and sessions) so you know who is editing a buggy</h2>
      <p>
        I decided to use Flask's builtin flask-login library, which allows for use of keeping track of current 
        logged in users and will prove to be useful later on the project.
        I created a model for the user table, it would hold their email, password, first and last name. 
        On top of which I also created a signup form for the signup page.
      </p>
    </div>
    <div class="task">
      <h2>4-REGISTER Make a new user</h2>
      <p>
        Before submitting to Database, the server checks that the password typed twice matches, 
        it also checks if that email is already in use in another account. Once everything is validated,
        the data is then added to the user's database.
      </p>
    </div>
    <div class="task">
      <h2>4-OWNER A buggy belongs to a user</h2>
      <p>
        I made sure to add the "@login_required" decorator to the create/edit/show/delete pages,
        otherwise each of those routes would break. I also had to add another column to the buggy 
        table called "user_id", so that only logged in user's could only access their own buggies, 
        even if they know another buggies' id.
      </p>
      <p>
        When adding the new column, I had to delete and recreate a new table in the database.
      </p>
    </div>
    <div class="task">
      <h2>4-PASS Add password protection to the users</h2>
      <p>
        Alongside with email, users must also provide a password when creating and logging into an account.
        I used bcrypt library as it had the most documentation avaiable and easier to use. When adding a new user
        the password entered must be hashed, as is best practice. Additionally, when logging in, to check 
        if password is correct, the method <code>check_password_hash</code> must be used.
      </p>
    </div>

<!-- this closes the section: keep it in! -->
</section>

{% endblock %}